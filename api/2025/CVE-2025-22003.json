{
  "affected_release": null,
  "package_state": [
    {
      "product_name": "Red Hat Enterprise Linux 6",
      "fix_state": "Not affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:6"
    },
    {
      "product_name": "Red Hat Enterprise Linux 7",
      "fix_state": "Not affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:7"
    },
    {
      "product_name": "Red Hat Enterprise Linux 7",
      "fix_state": "Not affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:7"
    },
    {
      "product_name": "Red Hat Enterprise Linux 8",
      "fix_state": "Not affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:8"
    },
    {
      "product_name": "Red Hat Enterprise Linux 8",
      "fix_state": "Not affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:8"
    },
    {
      "product_name": "Red Hat Enterprise Linux 9",
      "fix_state": "Not affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:9"
    },
    {
      "product_name": "Red Hat Enterprise Linux 9",
      "fix_state": "Not affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:9"
    }
  ],
  "threat_severity": "Moderate",
  "public_date": "2025-04-03T00:00:00Z",
  "bugzilla": {
    "description": "kernel: can: ucan: fix out of bound read in strscpy() source",
    "id": "2357133",
    "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2357133"
  },
  "cvss": {
    "cvss_base_score": "",
    "cvss_scoring_vector": "",
    "status": ""
  },
  "cvss3": {
    "cvss3_base_score": "5.5",
    "cvss3_scoring_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "status": "draft"
  },
  "iava": "",
  "cwe": "",
  "statement": "",
  "acknowledgement": "",
  "name": "CVE-2025-22003",
  "document_distribution": "",
  "details": [
    "In the Linux kernel, the following vulnerability has been resolved:\ncan: ucan: fix out of bound read in strscpy() source\nCommit 7fdaf8966aae (\"can: ucan: use strscpy() to instead of strncpy()\")\nunintentionally introduced a one byte out of bound read on strscpy()'s\nsource argument (which is kind of ironic knowing that strscpy() is meant\nto be a more secure alternative :)).\nLet's consider below buffers:\ndest[len + 1]; /* will be NUL terminated */\nsrc[len]; /* may not be NUL terminated */\nWhen doing:\nstrncpy(dest, src, len);\ndest[len] = '\\0';\nstrncpy() will read up to len bytes from src.\nOn the other hand:\nstrscpy(dest, src, len + 1);\nwill read up to len + 1 bytes from src, that is to say, an out of bound\nread of one byte will occur on src if it is not NUL terminated. Note\nthat the src[len] byte is never copied, but strscpy() still needs to\nread it to check whether a truncation occurred or not.\nThis exact pattern happened in ucan.\nThe root cause is that the source is not NUL terminated. Instead of\ndoing a copy in a local buffer, directly NUL terminate it as soon as\nusb_control_msg() returns. With this, the local firmware_str[] variable\ncan be removed.\nOn top of this do a couple refactors:\n- ucan_ctl_payload-\u003eraw is only used for the firmware string, so\nrename it to ucan_ctl_payload-\u003efw_str and change its type from u8 to\nchar.\n- ucan_device_request_in() is only used to retrieve the firmware\nstring, so rename it to ucan_get_fw_str() and refactor it to make it\ndirectly handle all the string termination logic."
  ],
  "references": [
    "https://www.cve.org/CVERecord?id=CVE-2025-22003\nhttps://nvd.nist.gov/vuln/detail/CVE-2025-22003\nhttps://lore.kernel.org/linux-cve-announce/2025040349-CVE-2025-22003-ea29@gregkh/T"
  ]
}
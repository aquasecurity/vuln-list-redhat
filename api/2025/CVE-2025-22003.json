{
  "affected_release": null,
  "package_state": null,
  "threat_severity": "",
  "public_date": "2025-04-03T07:19:05Z",
  "bugzilla": {
    "description": "can: ucan: fix out of bound read in strscpy() source",
    "id": "2357133",
    "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2357133"
  },
  "cvss": {
    "cvss_base_score": "",
    "cvss_scoring_vector": "",
    "status": ""
  },
  "cvss3": {
    "cvss3_base_score": "",
    "cvss3_scoring_vector": "",
    "status": ""
  },
  "iava": "",
  "cwe": "",
  "statement": "",
  "acknowledgement": "",
  "name": "CVE-2025-22003",
  "document_distribution": "",
  "details": [
    "In the Linux kernel, the following vulnerability has been resolved:\ncan: ucan: fix out of bound read in strscpy() source\nCommit 7fdaf8966aae (\"can: ucan: use strscpy() to instead of strncpy()\")\nunintentionally introduced a one byte out of bound read on strscpy()'s\nsource argument (which is kind of ironic knowing that strscpy() is meant\nto be a more secure alternative :)).\nLet's consider below buffers:\ndest[len + 1]; /* will be NUL terminated */\nsrc[len]; /* may not be NUL terminated */\nWhen doing:\nstrncpy(dest, src, len);\ndest[len] = '\\0';\nstrncpy() will read up to len bytes from src.\nOn the other hand:\nstrscpy(dest, src, len + 1);\nwill read up to len + 1 bytes from src, that is to say, an out of bound\nread of one byte will occur on src if it is not NUL terminated. Note\nthat the src[len] byte is never copied, but strscpy() still needs to\nread it to check whether a truncation occurred or not.\nThis exact pattern happened in ucan.\nThe root cause is that the source is not NUL terminated. Instead of\ndoing a copy in a local buffer, directly NUL terminate it as soon as\nusb_control_msg() returns. With this, the local firmware_str[] variable\ncan be removed.\nOn top of this do a couple refactors:\n- ucan_ctl_payload-\u003eraw is only used for the firmware string, so\nrename it to ucan_ctl_payload-\u003efw_str and change its type from u8 to\nchar.\n- ucan_device_request_in() is only used to retrieve the firmware\nstring, so rename it to ucan_get_fw_str() and refactor it to make it\ndirectly handle all the string termination logic."
  ],
  "references": [
    "https://www.cve.org/CVERecord?id=CVE-2025-22003\nhttps://nvd.nist.gov/vuln/detail/CVE-2025-22003\nhttps://git.kernel.org/stable/c/1d22a122ffb116c3cf78053e812b8b21f8852ee9\nhttps://git.kernel.org/stable/c/8cec9e314d3360fc1d8346297c41a6ee45cb45a9\nhttps://git.kernel.org/stable/c/a4994161a61bc8fd71d105c579d847cefee99262\nhttps://git.kernel.org/stable/c/cc29775a8a72d7f3b56cc026796ad99bd65804a7"
  ]
}
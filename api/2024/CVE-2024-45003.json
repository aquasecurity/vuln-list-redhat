{
  "affected_release": null,
  "package_state": [
    {
      "product_name": "Red Hat Enterprise Linux 6",
      "fix_state": "Out of support scope",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:6"
    },
    {
      "product_name": "Red Hat Enterprise Linux 7",
      "fix_state": "Out of support scope",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:7"
    },
    {
      "product_name": "Red Hat Enterprise Linux 7",
      "fix_state": "Out of support scope",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:7"
    },
    {
      "product_name": "Red Hat Enterprise Linux 8",
      "fix_state": "Affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:8"
    },
    {
      "product_name": "Red Hat Enterprise Linux 8",
      "fix_state": "Affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:8"
    },
    {
      "product_name": "Red Hat Enterprise Linux 9",
      "fix_state": "Affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:9"
    },
    {
      "product_name": "Red Hat Enterprise Linux 9",
      "fix_state": "Affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:9"
    }
  ],
  "threat_severity": "Moderate",
  "public_date": "2024-09-04T00:00:00Z",
  "bugzilla": {
    "description": "kernel: vfs: Don\u0026#39;t evict inode under the inode lru traversing context",
    "id": "2309866",
    "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2309866"
  },
  "cvss": {
    "cvss_base_score": "",
    "cvss_scoring_vector": "",
    "status": ""
  },
  "cvss3": {
    "cvss3_base_score": "5.5",
    "cvss3_scoring_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "status": "draft"
  },
  "iava": "",
  "cwe": "",
  "statement": "",
  "acknowledgement": "",
  "name": "CVE-2024-45003",
  "document_distribution": "",
  "details": [
    "In the Linux kernel, the following vulnerability has been resolved:\nvfs: Don't evict inode under the inode lru traversing context\nThe inode reclaiming process(See function prune_icache_sb) collects all\nreclaimable inodes and mark them with I_FREEING flag at first, at that\ntime, other processes will be stuck if they try getting these inodes\n(See function find_inode_fast), then the reclaiming process destroy the\ninodes by function dispose_list(). Some filesystems(eg. ext4 with\nea_inode feature, ubifs with xattr) may do inode lookup in the inode\nevicting callback function, if the inode lookup is operated under the\ninode lru traversing context, deadlock problems may happen.\nCase 1: In function ext4_evict_inode(), the ea inode lookup could happen\nif ea_inode feature is enabled, the lookup process will be stuck\nunder the evicting context like this:\n1. File A has inode i_reg and an ea inode i_ea\n2. getfattr(A, xattr_buf) // i_ea is added into lru // lru-\u003ei_ea\n3. Then, following three processes running like this:\nPA                              PB\necho 2 \u003e /proc/sys/vm/drop_caches\nshrink_slab\nprune_dcache_sb\n// i_reg is added into lru, lru-\u003ei_ea-\u003ei_reg\nprune_icache_sb\nlist_lru_walk_one\ninode_lru_isolate\ni_ea-\u003ei_state |= I_FREEING // set inode state\ninode_lru_isolate\n__iget(i_reg)\nspin_unlock(\u0026i_reg-\u003ei_lock)\nspin_unlock(lru_lock)\nrm file A\ni_reg-\u003enlink = 0\niput(i_reg) // i_reg-\u003enlink is 0, do evict\next4_evict_inode\next4_xattr_delete_inode\next4_xattr_inode_dec_ref_all\next4_xattr_inode_iget\next4_iget(i_ea-\u003ei_ino)\niget_locked\nfind_inode_fast\n__wait_on_freeing_inode(i_ea) ----→ AA deadlock\ndispose_list // cannot be executed by prune_icache_sb\nwake_up_bit(\u0026i_ea-\u003ei_state)\nCase 2: In deleted inode writing function ubifs_jnl_write_inode(), file\ndeleting process holds BASEHD's wbuf-\u003eio_mutex while getting the\nxattr inode, which could race with inode reclaiming process(The\nreclaiming process could try locking BASEHD's wbuf-\u003eio_mutex in\ninode evicting function), then an ABBA deadlock problem would\nhappen as following:\n1. File A has inode ia and a xattr(with inode ixa), regular file B has\ninode ib and a xattr.\n2. getfattr(A, xattr_buf) // ixa is added into lru // lru-\u003eixa\n3. Then, following three processes running like this:\nPA                PB                        PC\necho 2 \u003e /proc/sys/vm/drop_caches\nshrink_slab\nprune_dcache_sb\n// ib and ia are added into lru, lru-\u003eixa-\u003eib-\u003eia\nprune_icache_sb\nlist_lru_walk_one\ninode_lru_isolate\nixa-\u003ei_state |= I_FREEING // set inode state\ninode_lru_isolate\n__iget(ib)\nspin_unlock(\u0026ib-\u003ei_lock)\nspin_unlock(lru_lock)\nrm file B\nib-\u003enlink = 0\nrm file A\niput(ia)\nubifs_evict_inode(ia)\nubifs_jnl_delete_inode(ia)\nubifs_jnl_write_inode(ia)\nmake_reservation(BASEHD) // Lock wbuf-\u003eio_mutex\nubifs_iget(ixa-\u003ei_ino)\niget_locked\nfind_inode_fast\n__wait_on_freeing_inode(ixa)\n|          iput(ib) // ib-\u003enlink is 0, do evict\n|           ubifs_evict_inode\n|            ubifs_jnl_delete_inode(ib)\n↓             ubifs_jnl_write_inode\nABBA deadlock ←-----make_reservation(BASEHD)\ndispose_list // cannot be executed by prune_icache_sb\nwake_up_bit(\u0026ixa-\u003ei_state)\nFix the possible deadlock by using new inode state flag I_LRU_ISOLATING\nto pin the inode in memory while inode_lru_isolate(\n---truncated---"
  ],
  "references": [
    "https://www.cve.org/CVERecord?id=CVE-2024-45003\nhttps://nvd.nist.gov/vuln/detail/CVE-2024-45003\nhttps://lore.kernel.org/linux-cve-announce/2024090450-CVE-2024-45003-3bc2@gregkh/T"
  ]
}
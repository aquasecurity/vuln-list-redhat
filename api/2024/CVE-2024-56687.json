{
  "affected_release": null,
  "package_state": [
    {
      "product_name": "Red Hat Enterprise Linux 6",
      "fix_state": "Not affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:6"
    },
    {
      "product_name": "Red Hat Enterprise Linux 7",
      "fix_state": "Not affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:7"
    },
    {
      "product_name": "Red Hat Enterprise Linux 7",
      "fix_state": "Not affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:7"
    },
    {
      "product_name": "Red Hat Enterprise Linux 8",
      "fix_state": "Not affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:8"
    },
    {
      "product_name": "Red Hat Enterprise Linux 8",
      "fix_state": "Not affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:8"
    },
    {
      "product_name": "Red Hat Enterprise Linux 9",
      "fix_state": "Not affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:9"
    },
    {
      "product_name": "Red Hat Enterprise Linux 9",
      "fix_state": "Not affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:9"
    }
  ],
  "threat_severity": "Moderate",
  "public_date": "2024-12-28T00:00:00Z",
  "bugzilla": {
    "description": "kernel: usb: musb: Fix hardware lockup on first Rx endpoint request",
    "id": "2334669",
    "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2334669"
  },
  "cvss": {
    "cvss_base_score": "",
    "cvss_scoring_vector": "",
    "status": ""
  },
  "cvss3": {
    "cvss3_base_score": "5.5",
    "cvss3_scoring_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "status": "draft"
  },
  "iava": "",
  "cwe": "CWE-667",
  "statement": "",
  "acknowledgement": "",
  "name": "CVE-2024-56687",
  "document_distribution": "",
  "details": [
    "In the Linux kernel, the following vulnerability has been resolved:\nusb: musb: Fix hardware lockup on first Rx endpoint request\nThere is a possibility that a request's callback could be invoked from\nusb_ep_queue() (call trace below, supplemented with missing calls):\nreq-\u003ecomplete from usb_gadget_giveback_request\n(drivers/usb/gadget/udc/core.c:999)\nusb_gadget_giveback_request from musb_g_giveback\n(drivers/usb/musb/musb_gadget.c:147)\nmusb_g_giveback from rxstate\n(drivers/usb/musb/musb_gadget.c:784)\nrxstate from musb_ep_restart\n(drivers/usb/musb/musb_gadget.c:1169)\nmusb_ep_restart from musb_ep_restart_resume_work\n(drivers/usb/musb/musb_gadget.c:1176)\nmusb_ep_restart_resume_work from musb_queue_resume_work\n(drivers/usb/musb/musb_core.c:2279)\nmusb_queue_resume_work from musb_gadget_queue\n(drivers/usb/musb/musb_gadget.c:1241)\nmusb_gadget_queue from usb_ep_queue\n(drivers/usb/gadget/udc/core.c:300)\nAccording to the docstring of usb_ep_queue(), this should not happen:\n\"Note that @req's -\u003ecomplete() callback must never be called from within\nusb_ep_queue() as that can create deadlock situations.\"\nIn fact, a hardware lockup might occur in the following sequence:\n1. The gadget is initialized using musb_gadget_enable().\n2. Meanwhile, a packet arrives, and the RXPKTRDY flag is set, raising an\ninterrupt.\n3. If IRQs are enabled, the interrupt is handled, but musb_g_rx() finds an\nempty queue (next_request() returns NULL). The interrupt flag has\nalready been cleared by the glue layer handler, but the RXPKTRDY flag\nremains set.\n4. The first request is enqueued using usb_ep_queue(), leading to the call\nof req-\u003ecomplete(), as shown in the call trace above.\n5. If the callback enables IRQs and another packet is waiting, step (3)\nrepeats. The request queue is empty because usb_g_giveback() removes the\nrequest before invoking the callback.\n6. The endpoint remains locked up, as the interrupt triggered by hardware\nsetting the RXPKTRDY flag has been handled, but the flag itself remains\nset.\nFor this scenario to occur, it is only necessary for IRQs to be enabled at\nsome point during the complete callback. This happens with the USB Ethernet\ngadget, whose rx_complete() callback calls netif_rx(). If called in the\ntask context, netif_rx() disables the bottom halves (BHs). When the BHs are\nre-enabled, IRQs are also enabled to allow soft IRQs to be processed. The\ngadget itself is initialized at module load (or at boot if built-in), but\nthe first request is enqueued when the network interface is brought up,\ntriggering rx_complete() in the task context via ioctl(). If a packet\narrives while the interface is down, it can prevent the interface from\nreceiving any further packets from the USB host.\nThe situation is quite complicated with many parties involved. This\nparticular issue can be resolved in several possible ways:\n1. Ensure that callbacks never enable IRQs. This would be difficult to\nenforce, as discovering how netif_rx() interacts with interrupts was\nalready quite challenging and u_ether is not the only function driver.\nSimilar \"bugs\" could be hidden in other drivers as well.\n2. Disable MUSB interrupts in musb_g_giveback() before calling the callback\nand re-enable them afterwars (by calling musb_{dis,en}able_interrupts(),\nfor example). This would ensure that MUSB interrupts are not handled\nduring the callback, even if IRQs are enabled. In fact, it would allow\nIRQs to be enabled when releasing the lock. However, this feels like an\ninelegant hack.\n3. Modify the interrupt handler to clear the RXPKTRDY flag if the request\nqueue is empty. While this approach also feels like a hack, it wastes\nCPU time by attempting to handle incoming packets when the software is\nnot ready to process them.\n4. Flush the Rx FIFO instead of calling rxstate() in musb_ep_restart().\nThis ensures that the hardware can receive packets when there is at\nleast one request in the queue. Once I\n---truncated---"
  ],
  "references": [
    "https://www.cve.org/CVERecord?id=CVE-2024-56687\nhttps://nvd.nist.gov/vuln/detail/CVE-2024-56687\nhttps://lore.kernel.org/linux-cve-announce/2024122834-CVE-2024-56687-99e2@gregkh/T"
  ]
}
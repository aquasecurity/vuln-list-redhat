{
  "affected_release": null,
  "package_state": [
    {
      "product_name": "Red Hat Enterprise Linux 6",
      "fix_state": "Out of support scope",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:6"
    },
    {
      "product_name": "Red Hat Enterprise Linux 7",
      "fix_state": "Out of support scope",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:7"
    },
    {
      "product_name": "Red Hat Enterprise Linux 7",
      "fix_state": "Out of support scope",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:7"
    },
    {
      "product_name": "Red Hat Enterprise Linux 8",
      "fix_state": "Affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:8"
    },
    {
      "product_name": "Red Hat Enterprise Linux 8",
      "fix_state": "Affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:8"
    },
    {
      "product_name": "Red Hat Enterprise Linux 9",
      "fix_state": "Affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:9"
    },
    {
      "product_name": "Red Hat Enterprise Linux 9",
      "fix_state": "Affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:9"
    }
  ],
  "threat_severity": "Moderate",
  "public_date": "2024-07-17T00:00:00Z",
  "bugzilla": {
    "description": "kernel: bpf: Fix too early release of tcx_entry",
    "id": "2298411",
    "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2298411"
  },
  "cvss": {
    "cvss_base_score": "",
    "cvss_scoring_vector": "",
    "status": ""
  },
  "cvss3": {
    "cvss3_base_score": "5.5",
    "cvss3_scoring_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "status": "draft"
  },
  "iava": "",
  "cwe": "",
  "statement": "",
  "acknowledgement": "",
  "name": "CVE-2024-41010",
  "document_distribution": "",
  "details": [
    "In the Linux kernel, the following vulnerability has been resolved:\nbpf: Fix too early release of tcx_entry\nPedro Pinto and later independently also Hyunwoo Kim and Wongi Lee reported\nan issue that the tcx_entry can be released too early leading to a use\nafter free (UAF) when an active old-style ingress or clsact qdisc with a\nshared tc block is later replaced by another ingress or clsact instance.\nEssentially, the sequence to trigger the UAF (one example) can be as follows:\n1. A network namespace is created\n2. An ingress qdisc is created. This allocates a tcx_entry, and\n\u0026tcx_entry-\u003eminiq is stored in the qdisc's miniqp-\u003ep_miniq. At the\nsame time, a tcf block with index 1 is created.\n3. chain0 is attached to the tcf block. chain0 must be connected to\nthe block linked to the ingress qdisc to later reach the function\ntcf_chain0_head_change_cb_del() which triggers the UAF.\n4. Create and graft a clsact qdisc. This causes the ingress qdisc\ncreated in step 1 to be removed, thus freeing the previously linked\ntcx_entry:\nrtnetlink_rcv_msg()\n=\u003e tc_modify_qdisc()\n=\u003e qdisc_create()\n=\u003e clsact_init() [a]\n=\u003e qdisc_graft()\n=\u003e qdisc_destroy()\n=\u003e __qdisc_destroy()\n=\u003e ingress_destroy() [b]\n=\u003e tcx_entry_free()\n=\u003e kfree_rcu() // tcx_entry freed\n5. Finally, the network namespace is closed. This registers the\ncleanup_net worker, and during the process of releasing the\nremaining clsact qdisc, it accesses the tcx_entry that was\nalready freed in step 4, causing the UAF to occur:\ncleanup_net()\n=\u003e ops_exit_list()\n=\u003e default_device_exit_batch()\n=\u003e unregister_netdevice_many()\n=\u003e unregister_netdevice_many_notify()\n=\u003e dev_shutdown()\n=\u003e qdisc_put()\n=\u003e clsact_destroy() [c]\n=\u003e tcf_block_put_ext()\n=\u003e tcf_chain0_head_change_cb_del()\n=\u003e tcf_chain_head_change_item()\n=\u003e clsact_chain_head_change()\n=\u003e mini_qdisc_pair_swap() // UAF\nThere are also other variants, the gist is to add an ingress (or clsact)\nqdisc with a specific shared block, then to replace that qdisc, waiting\nfor the tcx_entry kfree_rcu() to be executed and subsequently accessing\nthe current active qdisc's miniq one way or another.\nThe correct fix is to turn the miniq_active boolean into a counter. What\ncan be observed, at step 2 above, the counter transitions from 0-\u003e1, at\nstep [a] from 1-\u003e2 (in order for the miniq object to remain active during\nthe replacement), then in [b] from 2-\u003e1 and finally [c] 1-\u003e0 with the\neventual release. The reference counter in general ranges from [0,2] and\nit does not need to be atomic since all access to the counter is protected\nby the rtnl mutex. With this in place, there is no longer a UAF happening\nand the tcx_entry is freed at the correct time."
  ],
  "references": [
    "https://www.cve.org/CVERecord?id=CVE-2024-41010\nhttps://nvd.nist.gov/vuln/detail/CVE-2024-41010"
  ]
}
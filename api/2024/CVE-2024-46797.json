{
  "mitigation": "Mitigation for this issue is either not available or the currently available options do not meet the Red Hat Product Security criteria comprising ease of use and deployment, applicability to widespread installation base or stability.",
  "affected_release": null,
  "package_state": [
    {
      "product_name": "Red Hat Enterprise Linux 6",
      "fix_state": "Not affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:6"
    },
    {
      "product_name": "Red Hat Enterprise Linux 7",
      "fix_state": "Not affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:7"
    },
    {
      "product_name": "Red Hat Enterprise Linux 7",
      "fix_state": "Not affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:7"
    },
    {
      "product_name": "Red Hat Enterprise Linux 8",
      "fix_state": "Not affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:8"
    },
    {
      "product_name": "Red Hat Enterprise Linux 8",
      "fix_state": "Not affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:8"
    },
    {
      "product_name": "Red Hat Enterprise Linux 9",
      "fix_state": "Fix deferred",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:9"
    },
    {
      "product_name": "Red Hat Enterprise Linux 9",
      "fix_state": "Fix deferred",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:9"
    }
  ],
  "threat_severity": "Low",
  "public_date": "2024-09-18T00:00:00Z",
  "bugzilla": {
    "description": "kernel: powerpc/qspinlock: Fix deadlock in MCS queue",
    "id": "2313145",
    "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2313145"
  },
  "cvss": {
    "cvss_base_score": "",
    "cvss_scoring_vector": "",
    "status": ""
  },
  "cvss3": {
    "cvss3_base_score": "4.7",
    "cvss3_scoring_vector": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "status": "draft"
  },
  "iava": "",
  "cwe": "CWE-667",
  "statement": "",
  "acknowledgement": "",
  "name": "CVE-2024-46797",
  "document_distribution": "",
  "details": [
    "In the Linux kernel, the following vulnerability has been resolved:\npowerpc/qspinlock: Fix deadlock in MCS queue\nIf an interrupt occurs in queued_spin_lock_slowpath() after we increment\nqnodesp-\u003ecount and before node-\u003elock is initialized, another CPU might\nsee stale lock values in get_tail_qnode(). If the stale lock value happens\nto match the lock on that CPU, then we write to the \"next\" pointer of\nthe wrong qnode. This causes a deadlock as the former CPU, once it becomes\nthe head of the MCS queue, will spin indefinitely until it's \"next\" pointer\nis set by its successor in the queue.\nRunning stress-ng on a 16 core (16EC/16VP) shared LPAR, results in\noccasional lockups similar to the following:\n$ stress-ng --all 128 --vm-bytes 80% --aggressive \\\n--maximize --oomable --verify  --syslog \\\n--metrics  --times  --timeout 5m\nwatchdog: CPU 15 Hard LOCKUP\n......\nNIP [c0000000000b78f4] queued_spin_lock_slowpath+0x1184/0x1490\nLR [c000000001037c5c] _raw_spin_lock+0x6c/0x90\nCall Trace:\n0xc000002cfffa3bf0 (unreliable)\n_raw_spin_lock+0x6c/0x90\nraw_spin_rq_lock_nested.part.135+0x4c/0xd0\nsched_ttwu_pending+0x60/0x1f0\n__flush_smp_call_function_queue+0x1dc/0x670\nsmp_ipi_demux_relaxed+0xa4/0x100\nxive_muxed_ipi_action+0x20/0x40\n__handle_irq_event_percpu+0x80/0x240\nhandle_irq_event_percpu+0x2c/0x80\nhandle_percpu_irq+0x84/0xd0\ngeneric_handle_irq+0x54/0x80\n__do_irq+0xac/0x210\n__do_IRQ+0x74/0xd0\n0x0\ndo_IRQ+0x8c/0x170\nhardware_interrupt_common_virt+0x29c/0x2a0\n--- interrupt: 500 at queued_spin_lock_slowpath+0x4b8/0x1490\n......\nNIP [c0000000000b6c28] queued_spin_lock_slowpath+0x4b8/0x1490\nLR [c000000001037c5c] _raw_spin_lock+0x6c/0x90\n--- interrupt: 500\n0xc0000029c1a41d00 (unreliable)\n_raw_spin_lock+0x6c/0x90\nfutex_wake+0x100/0x260\ndo_futex+0x21c/0x2a0\nsys_futex+0x98/0x270\nsystem_call_exception+0x14c/0x2f0\nsystem_call_vectored_common+0x15c/0x2ec\nThe following code flow illustrates how the deadlock occurs.\nFor the sake of brevity, assume that both locks (A and B) are\ncontended and we call the queued_spin_lock_slowpath() function.\nCPU0                                   CPU1\n----                                   ----\nspin_lock_irqsave(A)                          |\nspin_unlock_irqrestore(A)                     |\nspin_lock(B)                                |\n|                                      |\n▼                                      |\nid = qnodesp-\u003ecount++;                       |\n(Note that nodes[0].lock == A)                |\n|                                      |\n▼                                      |\nInterrupt                                 |\n(happens before \"nodes[0].lock = B\")          |\n|                                      |\n▼                                      |\nspin_lock_irqsave(A)                          |\n|                                      |\n▼                                      |\nid = qnodesp-\u003ecount++                        |\nnodes[1].lock = A                            |\n|                                      |\n▼                                      |\nTail of MCS queue                             |\n|                             spin_lock_irqsave(A)\n▼                                      |\nHead of MCS queue                             ▼\n|                             CPU0 is previous tail\n▼                                      |\nSpin indefinitely                            ▼\n(until \"nodes[1].next != NULL\")      prev = get_tail_qnode(A, CPU0)\n|\n▼\nprev == \u0026qnodes[CPU0].nodes[0]\n(as qnodes\n---truncated---",
    "An improper locking flaw was found in the PowerPC architecture implementation of the Linux Kernel's queued spinlocks in the queued_spin_lock_slowpath() function. This issue occurs due to the interaction between CPU interrupts and the queued spinlock mechanism. When an interrupt occurs at a critical moment in the locking process, stale lock values can lead to erroneous operations, causing the system to hang. If a local attacker or an application puts the system under heavy load, a deadlock can occur when multiple CPUs are contending for locks, resulting in a denial of service condition."
  ],
  "references": [
    "https://www.cve.org/CVERecord?id=CVE-2024-46797\nhttps://nvd.nist.gov/vuln/detail/CVE-2024-46797\nhttps://lore.kernel.org/linux-cve-announce/2024091856-CVE-2024-46797-9174@gregkh/T"
  ]
}
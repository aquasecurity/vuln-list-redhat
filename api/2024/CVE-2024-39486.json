{
  "mitigation": "Mitigation for this issue is either not available or the currently available options do not meet the Red Hat Product Security criteria comprising ease of use and deployment, applicability to widespread installation base or stability.",
  "affected_release": [
    {
      "product_name": "Red Hat Enterprise Linux 9",
      "release_date": "2024-11-12T00:00:00Z",
      "advisory": "RHSA-2024:9315",
      "package": "kernel-0:5.14.0-503.11.1.el9_5",
      "cpe": "cpe:/a:redhat:enterprise_linux:9"
    },
    {
      "product_name": "Red Hat Enterprise Linux 9",
      "release_date": "2024-11-12T00:00:00Z",
      "advisory": "RHSA-2024:9315",
      "package": "kernel-0:5.14.0-503.11.1.el9_5",
      "cpe": "cpe:/o:redhat:enterprise_linux:9"
    }
  ],
  "package_state": [
    {
      "product_name": "Red Hat Enterprise Linux 6",
      "fix_state": "Out of support scope",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:6"
    },
    {
      "product_name": "Red Hat Enterprise Linux 7",
      "fix_state": "Out of support scope",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:7"
    },
    {
      "product_name": "Red Hat Enterprise Linux 7",
      "fix_state": "Out of support scope",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:7"
    },
    {
      "product_name": "Red Hat Enterprise Linux 8",
      "fix_state": "Not affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:8"
    },
    {
      "product_name": "Red Hat Enterprise Linux 8",
      "fix_state": "Not affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:8"
    },
    {
      "product_name": "Red Hat Enterprise Linux 9",
      "fix_state": "Affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:9"
    }
  ],
  "threat_severity": "Moderate",
  "public_date": "2024-07-06T00:00:00Z",
  "bugzilla": {
    "description": "kernel: drm/drm_file: Fix pid refcounting race",
    "id": "2296383",
    "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2296383"
  },
  "cvss": {
    "cvss_base_score": "",
    "cvss_scoring_vector": "",
    "status": ""
  },
  "cvss3": {
    "cvss3_base_score": "5.5",
    "cvss3_scoring_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "status": "verified"
  },
  "iava": "",
  "cwe": "CWE-362",
  "statement": "",
  "acknowledgement": "",
  "name": "CVE-2024-39486",
  "document_distribution": "",
  "details": [
    "In the Linux kernel, the following vulnerability has been resolved:\ndrm/drm_file: Fix pid refcounting race\n\u003cmaarten.lankhorst@linux.intel.com\u003e, Maxime Ripard\n\u003cmripard@kernel.org\u003e, Thomas Zimmermann \u003ctzimmermann@suse.de\u003e\nfilp-\u003epid is supposed to be a refcounted pointer; however, before this\npatch, drm_file_update_pid() only increments the refcount of a struct\npid after storing a pointer to it in filp-\u003epid and dropping the\ndev-\u003efilelist_mutex, making the following race possible:\nprocess A               process B\n=========               =========\nbegin drm_file_update_pid\nmutex_lock(\u0026dev-\u003efilelist_mutex)\nrcu_replace_pointer(filp-\u003epid, \u003cpid B\u003e, 1)\nmutex_unlock(\u0026dev-\u003efilelist_mutex)\nbegin drm_file_update_pid\nmutex_lock(\u0026dev-\u003efilelist_mutex)\nrcu_replace_pointer(filp-\u003epid, \u003cpid A\u003e, 1)\nmutex_unlock(\u0026dev-\u003efilelist_mutex)\nget_pid(\u003cpid A\u003e)\nsynchronize_rcu()\nput_pid(\u003cpid B\u003e)   *** pid B reaches refcount 0 and is freed here ***\nget_pid(\u003cpid B\u003e)   *** UAF ***\nsynchronize_rcu()\nput_pid(\u003cpid A\u003e)\nAs far as I know, this race can only occur with CONFIG_PREEMPT_RCU=y\nbecause it requires RCU to detect a quiescent state in code that is not\nexplicitly calling into the scheduler.\nThis race leads to use-after-free of a \"struct pid\".\nIt is probably somewhat hard to hit because process A has to pass\nthrough a synchronize_rcu() operation while process B is between\nmutex_unlock() and get_pid().\nFix it by ensuring that by the time a pointer to the current task's pid\nis stored in the file, an extra reference to the pid has been taken.\nThis fix also removes the condition for synchronize_rcu(); I think\nthat optimization is unnecessary complexity, since in that case we\nwould usually have bailed out on the lockless check above.",
    "A race condition was found in the Linux kernel. The rm_file_update_pid() only increments the refcount of a struct pid after storing a pointer to it in filp-\u003epid, dropping the dev-\u003efilelist_mutex, resulting in a use-after-free vulnerability."
  ],
  "references": [
    "https://www.cve.org/CVERecord?id=CVE-2024-39486\nhttps://nvd.nist.gov/vuln/detail/CVE-2024-39486\nhttps://lore.kernel.org/linux-cve-announce/2024070628-CVE-2024-39486-1ea1@gregkh/T"
  ]
}